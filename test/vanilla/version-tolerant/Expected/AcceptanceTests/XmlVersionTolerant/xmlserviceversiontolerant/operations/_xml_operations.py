# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace

from .. import models as _models
from ..rest import xml as rest_xml

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar

    T = TypeVar("T")
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]


class XmlOperations(object):
    """XmlOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~xmlserviceversiontolerant.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def get_complex_type_ref_no_meta(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get a complex type that has a ref to a complex type with no XML node.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str (optional)"
                    },
                    "Something": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_complex_type_ref_no_meta_request(
            template_url=self.get_complex_type_ref_no_meta.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_complex_type_ref_no_meta.metadata = {"url": "/xml/complex-type-ref-no-meta"}  # type: ignore

    @distributed_trace
    def put_complex_type_ref_no_meta(
        self,
        model,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a complex type that has a ref to a complex type with no XML node.

        :param model:
        :type model: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                model = {
                    "RefToModel": {
                        "ID": "str (optional)"
                    },
                    "Something": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(model, "object", is_xml=True)

        request = rest_xml.build_put_complex_type_ref_no_meta_request(
            content_type=content_type,
            content=content,
            template_url=self.put_complex_type_ref_no_meta.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_complex_type_ref_no_meta.metadata = {"url": "/xml/complex-type-ref-no-meta"}  # type: ignore

    @distributed_trace
    def get_complex_type_ref_with_meta(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get a complex type that has a ref to a complex type with XML node.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str (optional)"
                    },
                    "Something": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_complex_type_ref_with_meta_request(
            template_url=self.get_complex_type_ref_with_meta.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_complex_type_ref_with_meta.metadata = {"url": "/xml/complex-type-ref-with-meta"}  # type: ignore

    @distributed_trace
    def put_complex_type_ref_with_meta(
        self,
        model,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a complex type that has a ref to a complex type with XML node.

        :param model:
        :type model: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                model = {
                    "RefToModel": {
                        "ID": "str (optional)"
                    },
                    "Something": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(model, "object", is_xml=True)

        request = rest_xml.build_put_complex_type_ref_with_meta_request(
            content_type=content_type,
            content=content,
            template_url=self.put_complex_type_ref_with_meta.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_complex_type_ref_with_meta.metadata = {"url": "/xml/complex-type-ref-with-meta"}  # type: ignore

    @distributed_trace
    def get_simple(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get a simple XML document.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str (optional)",
                    "date": "str (optional)",
                    "slides": [
                        {
                            "items": [
                                "str (optional)"
                            ],
                            "title": "str (optional)",
                            "type": "str (optional)"
                        }
                    ],
                    "title": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_simple_request(
            template_url=self.get_simple.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_simple.metadata = {"url": "/xml/simple"}  # type: ignore

    @distributed_trace
    def put_simple(
        self,
        slideshow,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put a simple XML document.

        :param slideshow:
        :type slideshow: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                slideshow = {
                    "author": "str (optional)",
                    "date": "str (optional)",
                    "slides": [
                        {
                            "items": [
                                "str (optional)"
                            ],
                            "title": "str (optional)",
                            "type": "str (optional)"
                        }
                    ],
                    "title": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(slideshow, "object", is_xml=True)

        request = rest_xml.build_put_simple_request(
            content_type=content_type,
            content=content,
            template_url=self.put_simple.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    put_simple.metadata = {"url": "/xml/simple"}  # type: ignore

    @distributed_trace
    def get_wrapped_lists(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get an XML document with multiple wrapped lists.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str (optional)"
                    ],
                    "GoodApples": [
                        "str (optional)"
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_wrapped_lists_request(
            template_url=self.get_wrapped_lists.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_wrapped_lists.metadata = {"url": "/xml/wrapped-lists"}  # type: ignore

    @distributed_trace
    def put_wrapped_lists(
        self,
        wrapped_lists,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with multiple wrapped lists.

        :param wrapped_lists:
        :type wrapped_lists: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                wrapped_lists = {
                    "BadApples": [
                        "str (optional)"
                    ],
                    "GoodApples": [
                        "str (optional)"
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(wrapped_lists, "object", is_xml=True)

        request = rest_xml.build_put_wrapped_lists_request(
            content_type=content_type,
            content=content,
            template_url=self.put_wrapped_lists.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    put_wrapped_lists.metadata = {"url": "/xml/wrapped-lists"}  # type: ignore

    @distributed_trace
    def get_headers(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Get strongly-typed response headers.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_headers_request(
            template_url=self.get_headers.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Custom-Header"] = self._deserialize("str", response.headers.get("Custom-Header"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    get_headers.metadata = {"url": "/xml/headers"}  # type: ignore

    @distributed_trace
    def get_empty_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get an empty list.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str (optional)",
                    "date": "str (optional)",
                    "slides": [
                        {
                            "items": [
                                "str (optional)"
                            ],
                            "title": "str (optional)",
                            "type": "str (optional)"
                        }
                    ],
                    "title": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_empty_list_request(
            template_url=self.get_empty_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_list.metadata = {"url": "/xml/empty-list"}  # type: ignore

    @distributed_trace
    def put_empty_list(
        self,
        slideshow,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts an empty list.

        :param slideshow:
        :type slideshow: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                slideshow = {
                    "author": "str (optional)",
                    "date": "str (optional)",
                    "slides": [
                        {
                            "items": [
                                "str (optional)"
                            ],
                            "title": "str (optional)",
                            "type": "str (optional)"
                        }
                    ],
                    "title": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(slideshow, "object", is_xml=True)

        request = rest_xml.build_put_empty_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_list.metadata = {"url": "/xml/empty-list"}  # type: ignore

    @distributed_trace
    def get_empty_wrapped_lists(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Gets some empty wrapped lists.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str (optional)"
                    ],
                    "GoodApples": [
                        "str (optional)"
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_empty_wrapped_lists_request(
            template_url=self.get_empty_wrapped_lists.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_wrapped_lists.metadata = {"url": "/xml/empty-wrapped-lists"}  # type: ignore

    @distributed_trace
    def put_empty_wrapped_lists(
        self,
        apple_barrel,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts some empty wrapped lists.

        :param apple_barrel:
        :type apple_barrel: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                apple_barrel = {
                    "BadApples": [
                        "str (optional)"
                    ],
                    "GoodApples": [
                        "str (optional)"
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(apple_barrel, "object", is_xml=True)

        request = rest_xml.build_put_empty_wrapped_lists_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_wrapped_lists.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_wrapped_lists.metadata = {"url": "/xml/empty-wrapped-lists"}  # type: ignore

    @distributed_trace
    def get_root_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[Any]
        """Gets a list as the root element.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JSON object, or the result of cls(response)
        :rtype: list[Any]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[Any]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_root_list_request(
            template_url=self.get_root_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_root_list.metadata = {"url": "/xml/root-list"}  # type: ignore

    @distributed_trace
    def put_root_list(
        self,
        bananas,  # type: List[Any]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a list as the root element.

        :param bananas:
        :type bananas: list[Any]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                bananas = [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = self._serialize.body(bananas, "[object]", is_xml=True, serialization_ctxt=serialization_ctxt)

        request = rest_xml.build_put_root_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_root_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_root_list.metadata = {"url": "/xml/root-list"}  # type: ignore

    @distributed_trace
    def get_root_list_single_item(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[Any]
        """Gets a list with a single item.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JSON object, or the result of cls(response)
        :rtype: list[Any]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[Any]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_root_list_single_item_request(
            template_url=self.get_root_list_single_item.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_root_list_single_item.metadata = {"url": "/xml/root-list-single-item"}  # type: ignore

    @distributed_trace
    def put_root_list_single_item(
        self,
        bananas,  # type: List[Any]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a list with a single item.

        :param bananas:
        :type bananas: list[Any]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                bananas = [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = self._serialize.body(bananas, "[object]", is_xml=True, serialization_ctxt=serialization_ctxt)

        request = rest_xml.build_put_root_list_single_item_request(
            content_type=content_type,
            content=content,
            template_url=self.put_root_list_single_item.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_root_list_single_item.metadata = {"url": "/xml/root-list-single-item"}  # type: ignore

    @distributed_trace
    def get_empty_root_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[Any]
        """Gets an empty list as the root element.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JSON object, or the result of cls(response)
        :rtype: list[Any]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[Any]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_empty_root_list_request(
            template_url=self.get_empty_root_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_root_list.metadata = {"url": "/xml/empty-root-list"}  # type: ignore

    @distributed_trace
    def put_empty_root_list(
        self,
        bananas,  # type: List[Any]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts an empty list as the root element.

        :param bananas:
        :type bananas: list[Any]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                bananas = [
                    {
                        "expiration": "datetime (optional)",
                        "flavor": "str (optional)",
                        "name": "str (optional)"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = self._serialize.body(bananas, "[object]", is_xml=True, serialization_ctxt=serialization_ctxt)

        request = rest_xml.build_put_empty_root_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_root_list.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_root_list.metadata = {"url": "/xml/empty-root-list"}  # type: ignore

    @distributed_trace
    def get_empty_child_element(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Gets an XML document with an empty child element.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "expiration": "datetime (optional)",
                    "flavor": "str (optional)",
                    "name": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_empty_child_element_request(
            template_url=self.get_empty_child_element.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_child_element.metadata = {"url": "/xml/empty-child-element"}  # type: ignore

    @distributed_trace
    def put_empty_child_element(
        self,
        banana,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a value with an empty child element.

        :param banana:
        :type banana: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                banana = {
                    "expiration": "datetime (optional)",
                    "flavor": "str (optional)",
                    "name": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(banana, "object", is_xml=True)

        request = rest_xml.build_put_empty_child_element_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_child_element.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_child_element.metadata = {"url": "/xml/empty-child-element"}  # type: ignore

    @distributed_trace
    def list_containers(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Lists containers in a storage account.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Containers": [
                        {
                            "Metadata": {
                                "str": "str (optional)"
                            },
                            "Name": "str",
                            "Properties": {
                                "Etag": "str",
                                "Last-Modified": "datetime",
                                "LeaseDuration": "str (optional)",
                                "LeaseState": "str (optional)",
                                "LeaseStatus": "str (optional)",
                                "PublicAccess": "str (optional)"
                            }
                        }
                    ],
                    "Marker": "str (optional)",
                    "MaxResults": "int",
                    "NextMarker": "str",
                    "Prefix": "str",
                    "ServiceEndpoint": "str"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_list_containers_request(
            template_url=self.list_containers.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_containers.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def get_service_properties(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Gets storage service properties.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",
                            "AllowedMethods": "str",
                            "AllowedOrigins": "str",
                            "ExposedHeaders": "str",
                            "MaxAgeInSeconds": "int"
                        }
                    ],
                    "DefaultServiceVersion": "str (optional)",
                    "DeleteRetentionPolicy": {
                        "Days": "int (optional)",
                        "Enabled": "bool"
                    },
                    "HourMetrics": {
                        "Enabled": "bool",
                        "IncludeAPIs": "bool (optional)",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str (optional)"
                    },
                    "Logging": {
                        "Delete": "bool",
                        "Read": "bool",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str",
                        "Write": "bool"
                    },
                    "MinuteMetrics": {
                        "Enabled": "bool",
                        "IncludeAPIs": "bool (optional)",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str (optional)"
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_service_properties_request(
            template_url=self.get_service_properties.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_service_properties.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def put_service_properties(
        self,
        properties,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts storage service properties.

        :param properties:
        :type properties: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                properties = {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",
                            "AllowedMethods": "str",
                            "AllowedOrigins": "str",
                            "ExposedHeaders": "str",
                            "MaxAgeInSeconds": "int"
                        }
                    ],
                    "DefaultServiceVersion": "str (optional)",
                    "DeleteRetentionPolicy": {
                        "Days": "int (optional)",
                        "Enabled": "bool"
                    },
                    "HourMetrics": {
                        "Enabled": "bool",
                        "IncludeAPIs": "bool (optional)",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str (optional)"
                    },
                    "Logging": {
                        "Delete": "bool",
                        "Read": "bool",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str",
                        "Write": "bool"
                    },
                    "MinuteMetrics": {
                        "Enabled": "bool",
                        "IncludeAPIs": "bool (optional)",
                        "RetentionPolicy": {
                            "Days": "int (optional)",
                            "Enabled": "bool"
                        },
                        "Version": "str (optional)"
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(properties, "object", is_xml=True)

        request = rest_xml.build_put_service_properties_request(
            content_type=content_type,
            content=content,
            template_url=self.put_service_properties.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_service_properties.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def get_acls(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[Any]
        """Gets storage ACLs for a container.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JSON object, or the result of cls(response)
        :rtype: list[Any]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "AccessPolicy": {
                            "Expiry": "datetime",
                            "Permission": "str",
                            "Start": "datetime"
                        },
                        "Id": "str"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[Any]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_acls_request(
            template_url=self.get_acls.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_acls.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def put_acls(
        self,
        properties,  # type: List[Any]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts storage ACLs for a container.

        :param properties:
        :type properties: list[Any]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                properties = [
                    {
                        "AccessPolicy": {
                            "Expiry": "datetime",
                            "Permission": "str",
                            "Start": "datetime"
                        },
                        "Id": "str"
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "SignedIdentifiers", "wrapped": True, "itemsName": "SignedIdentifier"}}
        content = self._serialize.body(properties, "[object]", is_xml=True, serialization_ctxt=serialization_ctxt)

        request = rest_xml.build_put_acls_request(
            content_type=content_type,
            content=content,
            template_url=self.put_acls.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_acls.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def list_blobs(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Lists blobs in a storage container.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Blobs": {
                        "Blob": [
                            {
                                "Deleted": "bool",
                                "Metadata": {
                                    "str": "str (optional)"
                                },
                                "Name": "str",
                                "Properties": {
                                    "AccessTier": "str (optional)",
                                    "AccessTierInferred": "bool (optional)",
                                    "ArchiveStatus": "str (optional)",
                                    "BlobType": "str (optional)",
                                    "Cache-Control": "str (optional)",
                                    "Content-Disposition": "str (optional)",
                                    "Content-Encoding": "str (optional)",
                                    "Content-Language": "str (optional)",
                                    "Content-Length": "long (optional)",
                                    "Content-MD5": "str (optional)",
                                    "Content-Type": "str (optional)",
                                    "CopyCompletionTime": "datetime (optional)",
                                    "CopyId": "str (optional)",
                                    "CopyProgress": "str (optional)",
                                    "CopySource": "str (optional)",
                                    "CopyStatus": "str (optional)",
                                    "CopyStatusDescription": "str (optional)",
                                    "DeletedTime": "datetime (optional)",
                                    "DestinationSnapshot": "str (optional)",
                                    "Etag": "str",
                                    "IncrementalCopy": "bool (optional)",
                                    "Last-Modified": "datetime",
                                    "LeaseDuration": "str (optional)",
                                    "LeaseState": "str (optional)",
                                    "LeaseStatus": "str (optional)",
                                    "RemainingRetentionDays": "int (optional)",
                                    "ServerEncrypted": "bool (optional)",
                                    "x-ms-blob-sequence-number": "int (optional)"
                                },
                                "Snapshot": "str"
                            }
                        ],
                        "BlobPrefix": [
                            {
                                "Name": "str"
                            }
                        ]
                    },
                    "ContainerName": "str",
                    "Delimiter": "str",
                    "Marker": "str",
                    "MaxResults": "int",
                    "NextMarker": "str",
                    "Prefix": "str",
                    "ServiceEndpoint": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_list_blobs_request(
            template_url=self.list_blobs.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_blobs.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def json_input(
        self,
        properties,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties:
        :type properties: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                properties = {
                    "id": "int (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        json = self._serialize.body(properties, "object")

        request = rest_xml.build_json_input_request(
            content_type=content_type,
            json=json,
            template_url=self.json_input.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    json_input.metadata = {"url": "/xml/jsoninput"}  # type: ignore

    @distributed_trace
    def json_output(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """A Swagger with XML that has one operation that returns JSON. ID number 42.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "id": "int (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_json_output_request(
            template_url=self.json_output.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    json_output.metadata = {"url": "/xml/jsonoutput"}  # type: ignore

    @distributed_trace
    def get_xms_text(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get back an XML object with an x-ms-text property, which should translate to the returned
        object's 'language' property being 'english' and its 'content' property being 'I am text'.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "content": "str (optional)",
                    "language": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_xms_text_request(
            template_url=self.get_xms_text.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_xms_text.metadata = {"url": "/xml/x-ms-text"}  # type: ignore

    @distributed_trace
    def get_bytes(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get an XML document with binary property.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Bytes": "bytearray (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_bytes_request(
            template_url=self.get_bytes.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_bytes.metadata = {"url": "/xml/bytes"}  # type: ignore

    @distributed_trace
    def put_binary(
        self,
        slideshow,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with binary property.

        :param slideshow:
        :type slideshow: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                slideshow = {
                    "Bytes": "bytearray (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(slideshow, "object", is_xml=True)

        request = rest_xml.build_put_binary_request(
            content_type=content_type,
            content=content,
            template_url=self.put_binary.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    put_binary.metadata = {"url": "/xml/bytes"}  # type: ignore

    @distributed_trace
    def get_uri(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Any
        """Get an XML document with uri property.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JSON object, or the result of cls(response)
        :rtype: Any
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Url": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Any]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = rest_xml.build_get_uri_request(
            template_url=self.get_uri.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_uri.metadata = {"url": "/xml/url"}  # type: ignore

    @distributed_trace
    def put_uri(
        self,
        model,  # type: Any
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with uri property.

        :param model:
        :type model: Any
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your `json` input.
                model = {
                    "Url": "str (optional)"
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = self._serialize.body(model, "object", is_xml=True)

        request = rest_xml.build_put_uri_request(
            content_type=content_type,
            content=content,
            template_url=self.put_uri.metadata["url"],
        )._to_pipeline_transport_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client.send_request(request, stream=False, _return_pipeline_response=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    put_uri.metadata = {"url": "/xml/url"}  # type: ignore
